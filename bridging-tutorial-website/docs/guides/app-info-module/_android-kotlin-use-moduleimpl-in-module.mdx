#### Use module-implementation in module

Let's combine module-implementation with RN's wrapper class

```diff title="android/src/newarch/java/com/appinfopackage/AppInfoModule.kt"
package com.appinfopackage

import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.module.annotations.ReactModule

/**
 * Declare Kotlin class for new arch native module implementation
 *
 * Each turbo module extends codegenerated spec class
 *
 * Class should be annotated with @ReactModule decorator
 */
@ReactModule(name = AppInfoModule.NAME)
class AppInfoModule(
    // Each native module class consumes react application context
    reactContext: ReactApplicationContext
) : NativeAppInfoModuleSpec(reactContext) {
// highlight-start
+   // Use shared module implementation and forward react application context
+   private val moduleImpl = AppInfoModuleImpl(reactContext)
+
+   // Return the name of the module - it should match the name provided in JS specification
+   override fun getName() = NAME
+
+   // Exported methods are overriden - based on the spec class
+   override fun getAppBuildNumber() = moduleImpl.getAppBuildNumber()
+
+   override fun getAppBundleId() = moduleImpl.getAppBundleId()
+
+   override fun getAppVersion() = moduleImpl.getAppVersion()
+
// highlight-end
    companion object {
// highlight-start
-       const val NAME = "NAME"
+       const val NAME = AppInfoModuleImpl.NAME
// highlight-end
    }
}
```

The main 2 things we are doing here are:

- using module-implementation methods to implement code-generated spec methods
- using module-implementation `NAME` value

<details>
  <summary>Old architecture module</summary>
  <div>
    The implementation of old architecture module won't be visible in Android Studio when you have new architecture enabled.
    If you want, you can open <code>android/src/oldarch/java/com/appinfopackage/AppInfoModule.kt</code> at other text editor and paste following content:
    <br /><br />

    package com.appinfopackage

    import com.facebook.react.bridge.ReactApplicationContext
    import com.facebook.react.bridge.ReactContextBaseJavaModule
    import com.facebook.react.bridge.ReactMethod
    import com.facebook.react.module.annotations.ReactModule

    /**
     * Declare Kotlin class for old arch native module implementation
     *
     * Each native module extends ReactContextBaseJavaModule class
     *
     * Class should be annotated with @ReactModule decorator
     */
    @ReactModule(name = AppInfoModule.NAME)
    class AppInfoModule(
        // Each native module class consumes react application context
        reactContext: ReactApplicationContext
    ) : ReactContextBaseJavaModule(reactContext) {
        // Use shared module implementation and forward react application context
        private val moduleImpl = AppInfoModuleImpl(reactContext)

        // Return the name of the module - it should match the name provided in JS specification
        override fun getName() = NAME

        // Exported methods must be annotated with @ReactMethod decorator
        @ReactMethod(isBlockingSynchronousMethod = true)
        fun getAppBuildNumber() = moduleImpl.getAppBuildNumber()

        @ReactMethod(isBlockingSynchronousMethod = true)
        fun getAppBundleId() = moduleImpl.getAppBundleId()

        @ReactMethod(isBlockingSynchronousMethod = true)
        fun getAppVersion() = moduleImpl.getAppVersion()

        companion object {
            const val NAME = AppInfoModuleImpl.NAME
        }
    }
  </div>
</details>
