#### Use module-implementation in module

Let's combine module-implementation with RN's wrapper class

```objc title="ios/RangeDatePickerModule.mm"
#import "RangeDatePickerModule.h"

// highlight-start
#import "RangeDatePickerModuleImpl.h"
// highlight-end

#if RCT_NEW_ARCH_ENABLED
/**
 * Import header file with codegenerated protocols based on the JS specification
 *
 * The name of the header matches the name provided in codegenConfig's `name` field in package.json
 */
#import "RangeDatePickerPackage.h"

// Each turbo module extends codegenerated spec class
@interface RangeDatePickerModule () <NativeRangeDatePickerModuleSpec>
@end
#endif

// highlight-start
@interface RangeDatePickerModule () <RangeDatePickerModuleDelegate>
@end
// highlight-end

// Declare the ObjC implementation for that native module class
// highlight-start
@implementation RangeDatePickerModule {
    RangeDatePickerModuleImpl *moduleImpl;
    RCTResponseSenderBlock callbackBlock;
    RCTPromiseResolveBlock resolveBlock;
    RCTPromiseRejectBlock rejectBlock;
}
// highlight-end

// Return the name of the module - it should match the name provided in JS specification
RCT_EXPORT_MODULE(RangeDatePickerModule)

// highlight-start
- (instancetype)init {
    self = [super init];
    if (self) {
        moduleImpl = [RangeDatePickerModuleImpl new];
        moduleImpl.delegate = self;
    }
    return self;
}
// highlight-end

// Declare if module should be initialized on the main queue
+ (BOOL)requiresMainQueueSetup
{
    return YES;
}

/**
 * If the module interacts with UIKit,
 * it can declare that its methods should be run on main queue
 */
- (dispatch_queue_t)methodQueue {
    return dispatch_get_main_queue();
}

// highlight-start
// Exported methods are overriden - based on the spec class
RCT_EXPORT_METHOD(showRangeDatePickerWithCallback:(NSString *)title
                                         onResult:(RCTResponseSenderBlock)onResult)
{
    if (callbackBlock != nil) {
        return;
    }
    callbackBlock = onResult;
    [moduleImpl showRangeDatePickerWithTitle:title];
}

#if RCT_NEW_ARCH_ENABLED
RCT_EXPORT_METHOD(showRangeDatePickerWithPromise:(JS::NativeRangeDatePickerModule::SpecShowRangeDatePickerWithPromiseConfig &)config
#else
RCT_EXPORT_METHOD(showRangeDatePickerWithPromise:(NSDictionary *)config
#endif
                                         resolve:(RCTPromiseResolveBlock)resolve
                                          reject:(RCTPromiseRejectBlock)reject)
{
#if RCT_NEW_ARCH_ENABLED
    NSString *title = config.title();
#else
    NSString *title = config[@"title"];
#endif
    if (resolveBlock != nil) {
        return;
    }
    resolveBlock = resolve;
    rejectBlock = reject;
    [moduleImpl showRangeDatePickerWithTitle:title];
}

- (void)onCancel
{
    if (callbackBlock != nil) {
        callbackBlock(nil);
        callbackBlock = nil;
    } else if (resolveBlock != nil) {
        resolveBlock(nil);
        resolveBlock = nil;
        rejectBlock = nil;
    }
}

- (void)onError:(NSError *)error
{
    if (callbackBlock != nil) {
        callbackBlock(nil);
        callbackBlock = nil;
    } else if (resolveBlock != nil) {
        rejectBlock(@"noVCErrorCode", [error localizedDescription], error);
        resolveBlock = nil;
        rejectBlock = nil;
    }
}

- (void)onResult:(NSDictionary *)resultDictionary
{
    if (callbackBlock != nil) {
        callbackBlock(@[resultDictionary]);
        callbackBlock = nil;
    } else if (resolveBlock != nil) {
        resolveBlock(resultDictionary);
        resolveBlock = nil;
        rejectBlock = nil;
    }
}
// highlight-end

#if RCT_NEW_ARCH_ENABLED
// Implement RCTTurboModule protocol
- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:
    (const facebook::react::ObjCTurboModule::InitParams &)params
{
    return std::make_shared<facebook::react::NativeRangeDatePickerModuleSpecJSI>(params);
}
#endif

@end
```

We begin by importing `RangeDatePickerModuleImpl` class.

Next we make `RangeDatePickerModule` class implementing the delegate protocol we created before.
After that, XCode will show you warning that delegate protocol methods are not implemented - we will do it later.

Now let's declare 4 private variables for the class - one for our module-implementation instance and the rest used to keep reference to callback/promise blocks.

Next step is to override initializer for our module class where the module-implementation instance is initialized and the delegate property is set.

The last part is to declare exported methods and implement delegate methods.
The first exported method uses `RCTResponseSenderBlock` variable to represent JS callback response.
The second exported method uses `RCTPromiseResolveBlock` & `RCTPromiseRejectBlock` variables to represent JS promise response.
