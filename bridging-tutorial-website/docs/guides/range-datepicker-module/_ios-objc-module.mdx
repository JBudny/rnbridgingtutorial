#### `RangeDatePickerModule.h`

Let's start with `ios/RangeDatePicker.h` - the header file for the module

```objc title="ios/RangeDatePicker.h"
#import <React/RCTBridgeModule.h>

/**
 * Declare the ObjC interface for that native module class.
 * 
 * It must extend NSObject (like every class in ObjC) and
 * implement RCTBridgeModule (like each RN native module).
 * 
 * If the module emits events, it must extend RCTEventEmitter class.
 */
@interface RangeDatePickerModule : NSObject<RCTBridgeModule>

@end
```

In the header file for `RangeDatePickerModule` class we declare our class extending `NSObject` (as every class in ObjC) and implementing `RCTBridgeModule` (as each RN iOS module class).

#### `RangeDatePickerModule.mm`

After declaring the header we proceed with the implementation for `RangeDatePickerModule` class:

```objc title="ios/RangeDatePickerModule.mm"
#import "RangeDatePickerModule.h"

#if RCT_NEW_ARCH_ENABLED
/**
 * Import header file with codegenerated protocols based on the JS specification
 *
 * The name of the header matches the name provided in codegenConfig's `name` field in package.json
 */
#import "RangeDatePickerPackage.h"

// Each turbo module extends codegenerated spec class
@interface RangeDatePickerModule () <NativeRangeDatePickerModuleSpec>
@end
#endif

// Declare the ObjC implementation for that native module class
@implementation RangeDatePickerModule

// Return the name of the module - it should match the name provided in JS specification
RCT_EXPORT_MODULE(RangeDatePickerModule)

// Declare if module should be initialized on the main queue
+ (BOOL)requiresMainQueueSetup
{
    return YES;
}

/**
 * If the module interacts with UIKit,
 * it can declare that its methods should be run on main queue
 */
- (dispatch_queue_t)methodQueue {
    return dispatch_get_main_queue();
}

#if RCT_NEW_ARCH_ENABLED
// Implement RCTTurboModule protocol
- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:
    (const facebook::react::ObjCTurboModule::InitParams &)params
{
    return std::make_shared<facebook::react::NativeRangeDatePickerModuleSpecJSI>(params);
}
#endif

@end
```

We start by declaring the foundation for the module:

- importing and implementing code-generated spec protocol for new architecture mode
- declaring implementation block for the class
- invoking `RCT_EXPORT_MODULE` with the name matching what was declared in JS specification
- implemeting `RCTTurboModule` protocol

You may also noticed one static method and one getter with `queue` in its names.
The former - `requireMainQueueSetup` - describes whether the module should be initialized on the main (UI) queue.
The latter - `methodQueue` - returns the queue on which all module's methods will be invoked.
This is handy if all methods has to be run on either some dedicated background queue or on main (UI) queue, because they interact with UI elements.
In this case, we will want to display the datepicker view, so to not use `dispatch_async(dispatch_get_main_queue(), ^{ ... });` for each method, we will simplify it by returning `dispatch_get_main_queue()` from the `methodQueue` getter.

:::tip

To learn more about dispatch queues in ObjC, you may visit Apple's [dedicated guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html).

:::
